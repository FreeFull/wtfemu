#![allow(non_camel_case_types, non_snake_case, dead_code)]
/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub(crate) struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub(crate) const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub(crate) fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub(crate) fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub(crate) fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub(crate) fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}

pub(crate) const ISAPNP_MEM_DISABLED: u32 = 0;
pub(crate) const ISAPNP_IO_DISABLED: u32 = 0;
pub(crate) const ISAPNP_IRQ_DISABLED: u32 = 0;
pub(crate) const ISAPNP_DMA_DISABLED: u32 = 4;
pub(crate) const ISAPNP_CARD_DISABLE: libc::c_uint = 0;
pub(crate) const ISAPNP_CARD_ENABLE: libc::c_uint = 1;
pub(crate) const ISAPNP_CARD_FORCE_CONFIG: libc::c_uint = 2;
pub(crate) const ISAPNP_CARD_NO_KEY: libc::c_uint = 3;
pub(crate) type _bindgen_ty_1 = libc::c_uint;
#[repr(C)]
pub(crate) struct isapnp_device_config_t {
    pub(crate) activate: u8,
    pub(crate) mem: [isapnp_device_config_t__bindgen_ty_1; 4usize],
    pub(crate) mem32: [isapnp_device_config_t__bindgen_ty_2; 4usize],
    pub(crate) io: [isapnp_device_config_t__bindgen_ty_3; 8usize],
    pub(crate) irq: [isapnp_device_config_t__bindgen_ty_4; 2usize],
    pub(crate) dma: [isapnp_device_config_t__bindgen_ty_5; 2usize],
}
#[repr(C)]
#[repr(align(4))]
pub(crate) struct isapnp_device_config_t__bindgen_ty_1 {
    pub(crate) _bitfield_align_1: [u32; 0],
    pub(crate) _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_isapnp_device_config_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<isapnp_device_config_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(isapnp_device_config_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isapnp_device_config_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(isapnp_device_config_t__bindgen_ty_1)
        )
    );
}
impl isapnp_device_config_t__bindgen_ty_1 {
    #[inline]
    pub(crate) fn base(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub(crate) fn set_base(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub(crate) fn set_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn new_bitfield_1(base: u32, size: u32) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let base: u32 = unsafe { ::std::mem::transmute(base) };
            base as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub(crate) struct isapnp_device_config_t__bindgen_ty_2 {
    pub(crate) base: u32,
    pub(crate) size: u32,
}

#[repr(C)]
pub(crate) struct isapnp_device_config_t__bindgen_ty_3 {
    pub(crate) base: u16,
}

#[repr(C, packed)]
pub(crate) struct isapnp_device_config_t__bindgen_ty_4 {
    pub(crate) _bitfield_align_1: [u8; 0],
    pub(crate) _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_isapnp_device_config_t__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<isapnp_device_config_t__bindgen_ty_4>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(isapnp_device_config_t__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isapnp_device_config_t__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(isapnp_device_config_t__bindgen_ty_4)
        )
    );
}
impl isapnp_device_config_t__bindgen_ty_4 {
    #[inline]
    pub(crate) fn irq(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub(crate) fn set_irq(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn level(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub(crate) fn set_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub(crate) fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn new_bitfield_1(
        irq: u8,
        level: u8,
        type_: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let irq: u8 = unsafe { ::std::mem::transmute(irq) };
            irq as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let level: u8 = unsafe { ::std::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
pub(crate) struct isapnp_device_config_t__bindgen_ty_5 {
    pub(crate) _bitfield_align_1: [u8; 0],
    pub(crate) _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_isapnp_device_config_t__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<isapnp_device_config_t__bindgen_ty_5>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(isapnp_device_config_t__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isapnp_device_config_t__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(isapnp_device_config_t__bindgen_ty_5)
        )
    );
}
impl isapnp_device_config_t__bindgen_ty_5 {
    #[inline]
    pub(crate) fn dma(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub(crate) fn set_dma(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn new_bitfield_1(dma: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let dma: u8 = unsafe { ::std::mem::transmute(dma) };
            dma as u64
        });
        __bindgen_bitfield_unit
    }
}

extern "C" {
    pub(crate) fn isapnp_add_card(
        rom: *mut u8,
        rom_size: u16,
        config_changed: ::std::option::Option<
            unsafe extern "C" fn(
                ld: u8,
                config: *mut isapnp_device_config_t,
                priv_: *mut libc::c_void,
            ),
        >,
        csn_changed: ::std::option::Option<unsafe extern "C" fn(csn: u8, priv_: *mut libc::c_void)>,
        read_vendor_reg: ::std::option::Option<
            unsafe extern "C" fn(ld: u8, reg: u8, priv_: *mut libc::c_void) -> u8,
        >,
        write_vendor_reg: ::std::option::Option<
            unsafe extern "C" fn(ld: u8, reg: u8, val: u8, priv_: *mut libc::c_void),
        >,
        priv_: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub(crate) fn isapnp_update_card_rom(priv_: *mut libc::c_void, rom: *mut u8, rom_size: u16);
}
extern "C" {
    pub(crate) fn isapnp_enable_card(priv_: *mut libc::c_void, enable: u8);
}
extern "C" {
    pub(crate) fn isapnp_set_csn(priv_: *mut libc::c_void, csn: u8);
}
extern "C" {
    pub(crate) fn isapnp_set_device_defaults(
        priv_: *mut libc::c_void,
        ldn: u8,
        config: *const isapnp_device_config_t,
    );
}
extern "C" {
    pub(crate) fn isapnp_reset_card(priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn isapnp_reset_device(priv_: *mut libc::c_void, ld: u8);
}
