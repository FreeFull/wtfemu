#![allow(non_camel_case_types, non_snake_case, dead_code)]
/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub(crate) struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub(crate) const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub(crate) fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub(crate) fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub(crate) fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub(crate) fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub(crate) struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub(crate) const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub(crate) unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub(crate) unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}

pub(crate) const MEM_MAP_TO_SHADOW_RAM_MASK: u32 = 1;
pub(crate) const MEM_MAP_TO_RAM_ADDR_MASK: u32 = 2;
pub(crate) const STATE_CPU: u32 = 0;
pub(crate) const STATE_BUS: u32 = 2;
pub(crate) const ACCESS_CPU: u32 = 1;
pub(crate) const ACCESS_CPU_SMM: u32 = 2;
pub(crate) const ACCESS_BUS: u32 = 4;
pub(crate) const ACCESS_BUS_SMM: u32 = 8;
pub(crate) const ACCESS_NORMAL: u32 = 5;
pub(crate) const ACCESS_SMM: u32 = 10;
pub(crate) const ACCESS_CPU_BOTH: u32 = 3;
pub(crate) const ACCESS_BUS_BOTH: u32 = 12;
pub(crate) const ACCESS_ALL: u32 = 15;
pub(crate) const ACCESS_INTERNAL: u32 = 1;
pub(crate) const ACCESS_ROMCS: u32 = 2;
pub(crate) const ACCESS_SMRAM: u32 = 4;
pub(crate) const ACCESS_CACHE: u32 = 8;
pub(crate) const ACCESS_DISABLED: u32 = 16;
pub(crate) const ACCESS_X_INTERNAL: u32 = 1;
pub(crate) const ACCESS_X_ROMCS: u32 = 2;
pub(crate) const ACCESS_X_SMRAM: u32 = 4;
pub(crate) const ACCESS_X_CACHE: u32 = 8;
pub(crate) const ACCESS_X_DISABLED: u32 = 16;
pub(crate) const ACCESS_W_INTERNAL: u32 = 32;
pub(crate) const ACCESS_W_ROMCS: u32 = 64;
pub(crate) const ACCESS_W_SMRAM: u32 = 128;
pub(crate) const ACCESS_W_CACHE: u32 = 256;
pub(crate) const ACCESS_W_DISABLED: u32 = 512;
pub(crate) const ACCESS_R_INTERNAL: u32 = 1024;
pub(crate) const ACCESS_R_ROMCS: u32 = 2048;
pub(crate) const ACCESS_R_SMRAM: u32 = 4096;
pub(crate) const ACCESS_R_CACHE: u32 = 8192;
pub(crate) const ACCESS_R_DISABLED: u32 = 16384;
pub(crate) const ACCESS_EXECUTE: u32 = 0;
pub(crate) const ACCESS_READ: u32 = 1;
pub(crate) const ACCESS_WRITE: u32 = 2;
pub(crate) const ACCESS_SMRAM_OFF: u32 = 0;
pub(crate) const ACCESS_SMRAM_X: u32 = 1;
pub(crate) const ACCESS_SMRAM_W: u32 = 2;
pub(crate) const ACCESS_SMRAM_WX: u32 = 3;
pub(crate) const ACCESS_SMRAM_R: u32 = 4;
pub(crate) const ACCESS_SMRAM_RX: u32 = 5;
pub(crate) const ACCESS_SMRAM_RW: u32 = 6;
pub(crate) const ACCESS_SMRAM_RWX: u32 = 7;
pub(crate) const MEM_READ_DISABLED: u32 = 16400;
pub(crate) const MEM_READ_INTERNAL: u32 = 1025;
pub(crate) const MEM_READ_EXTERNAL: u32 = 0;
pub(crate) const MEM_READ_ROMCS: u32 = 2050;
pub(crate) const MEM_READ_EXTANY: u32 = 2050;
pub(crate) const MEM_READ_EXTERNAL_EX: u32 = 0;
pub(crate) const MEM_READ_SMRAM: u32 = 4100;
pub(crate) const MEM_READ_CACHE: u32 = 8200;
pub(crate) const MEM_READ_SMRAM_EX: u32 = 4;
pub(crate) const MEM_EXEC_SMRAM: u32 = 4;
pub(crate) const MEM_READ_SMRAM_2: u32 = 4096;
pub(crate) const MEM_READ_DISABLED_EX: u32 = 16400;
pub(crate) const MEM_READ_MASK: u32 = 31775;
pub(crate) const MEM_WRITE_DISABLED: u32 = 512;
pub(crate) const MEM_WRITE_INTERNAL: u32 = 32;
pub(crate) const MEM_WRITE_EXTERNAL: u32 = 0;
pub(crate) const MEM_WRITE_ROMCS: u32 = 64;
pub(crate) const MEM_WRITE_EXTANY: u32 = 64;
pub(crate) const MEM_WRITE_SMRAM: u32 = 128;
pub(crate) const MEM_WRITE_CACHE: u32 = 256;
pub(crate) const MEM_WRITE_DISABLED_EX: u32 = 16400;
pub(crate) const MEM_WRITE_MASK: u32 = 992;
pub(crate) const MEM_MAPPING_EXTERNAL: u32 = 1;
pub(crate) const MEM_MAPPING_INTERNAL: u32 = 2;
pub(crate) const MEM_MAPPING_ROM_WS: u32 = 4;
pub(crate) const MEM_MAPPING_IS_ROM: u32 = 8;
pub(crate) const MEM_MAPPING_ROM: u32 = 12;
pub(crate) const MEM_MAPPING_ROMCS: u32 = 16;
pub(crate) const MEM_MAPPING_SMRAM: u32 = 32;
pub(crate) const MEM_MAPPING_CACHE: u32 = 64;
pub(crate) const MEM_GRANULARITY_BITS: u32 = 12;
pub(crate) const MEM_GRANULARITY_SIZE: u32 = 4096;
pub(crate) const MEM_GRANULARITY_HBOUND: u32 = 4094;
pub(crate) const MEM_GRANULARITY_QBOUND: u32 = 4092;
pub(crate) const MEM_GRANULARITY_MASK: u32 = 4095;
pub(crate) const MEM_GRANULARITY_HMASK: u32 = 2047;
pub(crate) const MEM_GRANULARITY_QMASK: u32 = 1023;
pub(crate) const MEM_GRANULARITY_PMASK: u32 = 511;
pub(crate) const MEM_MAPPINGS_NO: u32 = 1048576;
pub(crate) const MEM_GRANULARITY_PAGE: u32 = 0;
pub(crate) const MEM_GRANULARITY_BASE: i32 = -4096;
#[repr(C)]
#[repr(align(2))]
pub(crate) struct state_t {
    pub(crate) _bitfield_align_1: [u8; 0],
    pub(crate) _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_state_t() {
    assert_eq!(
        ::std::mem::size_of::<state_t>(),
        2usize,
        concat!("Size of: ", stringify!(state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<state_t>(),
        2usize,
        concat!("Alignment of ", stringify!(state_t))
    );
}
impl state_t {
    #[inline]
    pub(crate) fn x(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_x(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn w(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_w(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn r(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_r(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn pad(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_pad(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn new_bitfield_1(
        x: u16,
        w: u16,
        r: u16,
        pad: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let x: u16 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let w: u16 = unsafe { ::std::mem::transmute(w) };
            w as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let r: u16 = unsafe { ::std::mem::transmute(r) };
            r as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pad: u16 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub(crate) struct mem_state_t {
    pub(crate) vals: __BindgenUnionField<[u16; 4usize]>,
    pub(crate) states: __BindgenUnionField<[state_t; 4usize]>,
    pub(crate) bindgen_union_field: [u16; 4usize],
}

#[repr(C)]
pub(crate) struct _mem_mapping_ {
    pub(crate) prev: *mut _mem_mapping_,
    pub(crate) next: *mut _mem_mapping_,
    pub(crate) enable: libc::c_int,
    pub(crate) base: u32,
    pub(crate) size: u32,
    pub(crate) read_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u8>,
    pub(crate) read_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u16>,
    pub(crate) read_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u32>,
    pub(crate) write_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u8, priv_: *mut libc::c_void)>,
    pub(crate) write_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u16, priv_: *mut libc::c_void)>,
    pub(crate) write_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u32, priv_: *mut libc::c_void)>,
    pub(crate) exec: *mut u8,
    pub(crate) flags: u32,
    pub(crate) p: *mut libc::c_void,
}
pub(crate) type mem_mapping_t = _mem_mapping_;
#[repr(C)]
pub(crate) struct _page_ {
    pub(crate) write_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u8, p: *mut _page_)>,
    pub(crate) write_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u16, p: *mut _page_)>,
    pub(crate) write_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u32, p: *mut _page_)>,
    pub(crate) mem: *mut u8,
    pub(crate) code_present_mask: [u64; 4usize],
    pub(crate) dirty_mask: [u64; 4usize],
    pub(crate) block: [*mut codeblock_t; 4usize],
    pub(crate) block_2: [*mut codeblock_t; 4usize],
    pub(crate) head: *mut codeblock_t,
}
pub(crate) type page_t = _page_;
extern "C" {
    pub(crate) static mut ram: *mut u8;
}
extern "C" {
    pub(crate) static mut ram2: *mut u8;
}
extern "C" {
    pub(crate) static mut rammask: u32;
}
extern "C" {
    pub(crate) static mut rom: *mut u8;
}
extern "C" {
    pub(crate) static mut biosmask: u32;
}
extern "C" {
    pub(crate) static mut biosaddr: u32;
}
extern "C" {
    pub(crate) static mut readlookup: [libc::c_int; 256usize];
}
extern "C" {
    pub(crate) static mut readlookup2: *mut usize;
}
extern "C" {
    pub(crate) static mut old_rl2: usize;
}
extern "C" {
    pub(crate) static mut uncached: u8;
}
extern "C" {
    pub(crate) static mut readlnext: libc::c_int;
}
extern "C" {
    pub(crate) static mut writelookup: [libc::c_int; 256usize];
}
extern "C" {
    pub(crate) static mut writelookup2: *mut usize;
}
extern "C" {
    pub(crate) static mut writelnext: libc::c_int;
}
extern "C" {
    pub(crate) static mut ram_mapped_addr: [u32; 64usize];
}
extern "C" {
    pub(crate) static mut ram_low_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_mid_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_remapped_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_high_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_2gb_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut bios_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut bios_high_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut mem_logical_addr: u32;
}
extern "C" {
    pub(crate) static mut pages: *mut page_t;
}
extern "C" {
    pub(crate) static mut page_lookup: *mut *mut page_t;
}
extern "C" {
    pub(crate) static mut get_phys_virt: u32;
}
extern "C" {
    pub(crate) static mut get_phys_phys: u32;
}
extern "C" {
    pub(crate) static mut shadowbios: libc::c_int;
}
extern "C" {
    pub(crate) static mut shadowbios_write: libc::c_int;
}
extern "C" {
    pub(crate) static mut readlnum: libc::c_int;
}
extern "C" {
    pub(crate) static mut writelnum: libc::c_int;
}
extern "C" {
    pub(crate) static mut memspeed: [libc::c_int; 11usize];
}
extern "C" {
    pub(crate) static mut mmu_perm: libc::c_int;
}
extern "C" {
    pub(crate) static mut high_page: u8;
}
extern "C" {
    pub(crate) static mut mem_a20_state: libc::c_int;
}
extern "C" {
    pub(crate) static mut mem_a20_alt: libc::c_int;
}
extern "C" {
    pub(crate) static mut mem_a20_key: libc::c_int;
}
extern "C" {
    pub(crate) fn read_mem_b(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn read_mem_w(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn write_mem_b(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn write_mem_w(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn readmembl(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn writemembl(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn readmemwl(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn writememwl(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn readmemll(addr: u32) -> u32;
}
extern "C" {
    pub(crate) fn writememll(addr: u32, val: u32);
}
extern "C" {
    pub(crate) fn readmemql(addr: u32) -> u64;
}
extern "C" {
    pub(crate) fn writememql(addr: u32, val: u64);
}
extern "C" {
    pub(crate) fn readmembl_no_mmut(addr: u32, a64: u32) -> u8;
}
extern "C" {
    pub(crate) fn writemembl_no_mmut(addr: u32, a64: u32, val: u8);
}
extern "C" {
    pub(crate) fn readmemwl_no_mmut(addr: u32, a64: *mut u32) -> u16;
}
extern "C" {
    pub(crate) fn writememwl_no_mmut(addr: u32, a64: *mut u32, val: u16);
}
extern "C" {
    pub(crate) fn readmemll_no_mmut(addr: u32, a64: *mut u32) -> u32;
}
extern "C" {
    pub(crate) fn writememll_no_mmut(addr: u32, a64: *mut u32, val: u32);
}
extern "C" {
    pub(crate) fn do_mmutranslate(addr: u32, a64: *mut u32, num: libc::c_int, write: libc::c_int);
}
extern "C" {
    pub(crate) fn getpccache(a: u32) -> *mut u8;
}
extern "C" {
    pub(crate) fn mmutranslatereal(addr: u32, rw: libc::c_int) -> u64;
}
extern "C" {
    pub(crate) fn mmutranslatereal32(addr: u32, rw: libc::c_int) -> u32;
}
extern "C" {
    pub(crate) fn addreadlookup(virt: u32, phys: u32);
}
extern "C" {
    pub(crate) fn addwritelookup(virt: u32, phys: u32);
}
extern "C" {
    pub(crate) fn mem_mapping_set(
        arg1: *mut mem_mapping_t,
        base: u32,
        size: u32,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
        exec: *mut u8,
        flags: u32,
        p: *mut libc::c_void,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_add(
        arg1: *mut mem_mapping_t,
        base: u32,
        size: u32,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
        exec: *mut u8,
        flags: u32,
        p: *mut libc::c_void,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_set_handler(
        arg1: *mut mem_mapping_t,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_set_p(arg1: *mut mem_mapping_t, p: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_mapping_set_addr(arg1: *mut mem_mapping_t, base: u32, size: u32);
}
extern "C" {
    pub(crate) fn mem_mapping_set_exec(arg1: *mut mem_mapping_t, exec: *mut u8);
}
extern "C" {
    pub(crate) fn mem_mapping_disable(arg1: *mut mem_mapping_t);
}
extern "C" {
    pub(crate) fn mem_mapping_enable(arg1: *mut mem_mapping_t);
}
extern "C" {
    pub(crate) fn mem_mapping_recalc(base: u64, size: u64);
}
extern "C" {
    pub(crate) fn mem_set_access(bitmap: u8, mode: libc::c_int, base: u32, size: u32, access: u16);
}
extern "C" {
    pub(crate) fn mem_readb_phys(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn mem_readw_phys(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn mem_readl_phys(addr: u32) -> u32;
}
extern "C" {
    pub(crate) fn mem_read_phys(dest: *mut libc::c_void, addr: u32, tranfer_size: libc::c_int);
}
extern "C" {
    pub(crate) fn mem_writeb_phys(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn mem_writew_phys(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn mem_writel_phys(addr: u32, val: u32);
}
extern "C" {
    pub(crate) fn mem_write_phys(src: *mut libc::c_void, addr: u32, tranfer_size: libc::c_int);
}
extern "C" {
    pub(crate) fn mem_read_ram(addr: u32, priv_: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn mem_read_ramw(addr: u32, priv_: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn mem_read_raml(addr: u32, priv_: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn mem_write_ram(addr: u32, val: u8, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ramw(addr: u32, val: u16, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_raml(addr: u32, val: u32, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_read_ram_2gb(addr: u32, priv_: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn mem_read_ram_2gbw(addr: u32, priv_: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn mem_read_ram_2gbl(addr: u32, priv_: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn mem_write_ram_2gb(addr: u32, val: u8, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ram_2gbw(addr: u32, val: u16, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ram_2gbl(addr: u32, val: u32, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_addr_is_ram(addr: u32) -> libc::c_int;
}
extern "C" {
    pub(crate) fn mmutranslate_noabrt(addr: u32, rw: libc::c_int) -> u64;
}
extern "C" {
    pub(crate) fn mem_invalidate_range(start_addr: u32, end_addr: u32);
}
extern "C" {
    pub(crate) fn mem_write_ramb_page(addr: u32, val: u8, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_write_ramw_page(addr: u32, val: u16, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_write_raml_page(addr: u32, val: u32, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_flush_write_page(addr: u32, virt: u32);
}
extern "C" {
    pub(crate) fn mem_reset_page_blocks();
}
extern "C" {
    pub(crate) fn flushmmucache();
}
extern "C" {
    pub(crate) fn flushmmucache_nopc();
}
extern "C" {
    pub(crate) fn mmu_invalidate(addr: u32);
}
extern "C" {
    pub(crate) fn mem_a20_init();
}
extern "C" {
    pub(crate) fn mem_a20_recalc();
}
extern "C" {
    pub(crate) fn mem_init();
}
extern "C" {
    pub(crate) fn mem_close();
}
extern "C" {
    pub(crate) fn mem_reset();
}
extern "C" {
    pub(crate) fn mem_remap_top(kb: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct codeblock_t {
    pub(crate) _address: u8,
}
