#![allow(
    non_camel_case_types,
    non_snake_case,
    dead_code,
    non_upper_case_globals
)]
use crate::prelude::*;
/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub(crate) struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub(crate) const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub(crate) fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub(crate) fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub(crate) fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub(crate) fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}

pub(crate) const INT8_MIN: i32 = -128;
pub(crate) const INT16_MIN: i32 = -32768;
pub(crate) const INT32_MIN: i32 = -2147483648;
pub(crate) const INT8_MAX: u32 = 127;
pub(crate) const INT16_MAX: u32 = 32767;
pub(crate) const INT32_MAX: u32 = 2147483647;
pub(crate) const UINT8_MAX: u32 = 255;
pub(crate) const UINT16_MAX: u32 = 65535;
pub(crate) const UINT32_MAX: u32 = 4294967295;
pub(crate) const INT_LEAST8_MIN: i32 = -128;
pub(crate) const INT_LEAST16_MIN: i32 = -32768;
pub(crate) const INT_LEAST32_MIN: i32 = -2147483648;
pub(crate) const INT_LEAST8_MAX: u32 = 127;
pub(crate) const INT_LEAST16_MAX: u32 = 32767;
pub(crate) const INT_LEAST32_MAX: u32 = 2147483647;
pub(crate) const UINT_LEAST8_MAX: u32 = 255;
pub(crate) const UINT_LEAST16_MAX: u32 = 65535;
pub(crate) const UINT_LEAST32_MAX: u32 = 4294967295;
pub(crate) const INT_FAST8_MIN: i32 = -128;
pub(crate) const INT_FAST16_MIN: i64 = -9223372036854775808;
pub(crate) const INT_FAST32_MIN: i64 = -9223372036854775808;
pub(crate) const INT_FAST8_MAX: u32 = 127;
pub(crate) const INT_FAST16_MAX: u64 = 9223372036854775807;
pub(crate) const INT_FAST32_MAX: u64 = 9223372036854775807;
pub(crate) const UINT_FAST8_MAX: u32 = 255;
pub(crate) const UINT_FAST16_MAX: i32 = -1;
pub(crate) const UINT_FAST32_MAX: i32 = -1;
pub(crate) const INTPTR_MIN: i64 = -9223372036854775808;
pub(crate) const INTPTR_MAX: u64 = 9223372036854775807;
pub(crate) const UINTPTR_MAX: i32 = -1;
pub(crate) const PTRDIFF_MIN: i64 = -9223372036854775808;
pub(crate) const PTRDIFF_MAX: u64 = 9223372036854775807;
pub(crate) const SIG_ATOMIC_MIN: i32 = -2147483648;
pub(crate) const SIG_ATOMIC_MAX: u32 = 2147483647;
pub(crate) const SIZE_MAX: i32 = -1;
pub(crate) const WINT_MIN: u32 = 0;
pub(crate) const WINT_MAX: u32 = 4294967295;

pub(crate) const P_tmpdir: &[u8; 5usize] = b"/tmp\0";

pub(crate) const L_tmpnam: u32 = 20;
pub(crate) const TMP_MAX: u32 = 238328;
pub(crate) const FILENAME_MAX: u32 = 4096;
pub(crate) const L_ctermid: u32 = 9;
pub(crate) const FOPEN_MAX: u32 = 16;

pub(crate) const MEM_MAP_TO_SHADOW_RAM_MASK: u32 = 1;
pub(crate) const MEM_MAP_TO_RAM_ADDR_MASK: u32 = 2;
pub(crate) const STATE_CPU: u32 = 0;
pub(crate) const STATE_BUS: u32 = 2;
pub(crate) const ACCESS_CPU: u32 = 1;
pub(crate) const ACCESS_CPU_SMM: u32 = 2;
pub(crate) const ACCESS_BUS: u32 = 4;
pub(crate) const ACCESS_BUS_SMM: u32 = 8;
pub(crate) const ACCESS_NORMAL: u32 = 5;
pub(crate) const ACCESS_SMM: u32 = 10;
pub(crate) const ACCESS_CPU_BOTH: u32 = 3;
pub(crate) const ACCESS_BUS_BOTH: u32 = 12;
pub(crate) const ACCESS_ALL: u32 = 15;
pub(crate) const ACCESS_INTERNAL: u32 = 1;
pub(crate) const ACCESS_ROMCS: u32 = 2;
pub(crate) const ACCESS_SMRAM: u32 = 4;
pub(crate) const ACCESS_CACHE: u32 = 8;
pub(crate) const ACCESS_DISABLED: u32 = 16;
pub(crate) const ACCESS_X_INTERNAL: u32 = 1;
pub(crate) const ACCESS_X_ROMCS: u32 = 2;
pub(crate) const ACCESS_X_SMRAM: u32 = 4;
pub(crate) const ACCESS_X_CACHE: u32 = 8;
pub(crate) const ACCESS_X_DISABLED: u32 = 16;
pub(crate) const ACCESS_W_INTERNAL: u32 = 32;
pub(crate) const ACCESS_W_ROMCS: u32 = 64;
pub(crate) const ACCESS_W_SMRAM: u32 = 128;
pub(crate) const ACCESS_W_CACHE: u32 = 256;
pub(crate) const ACCESS_W_DISABLED: u32 = 512;
pub(crate) const ACCESS_R_INTERNAL: u32 = 1024;
pub(crate) const ACCESS_R_ROMCS: u32 = 2048;
pub(crate) const ACCESS_R_SMRAM: u32 = 4096;
pub(crate) const ACCESS_R_CACHE: u32 = 8192;
pub(crate) const ACCESS_R_DISABLED: u32 = 16384;
pub(crate) const ACCESS_EXECUTE: u32 = 0;
pub(crate) const ACCESS_READ: u32 = 1;
pub(crate) const ACCESS_WRITE: u32 = 2;
pub(crate) const ACCESS_SMRAM_OFF: u32 = 0;
pub(crate) const ACCESS_SMRAM_X: u32 = 1;
pub(crate) const ACCESS_SMRAM_W: u32 = 2;
pub(crate) const ACCESS_SMRAM_WX: u32 = 3;
pub(crate) const ACCESS_SMRAM_R: u32 = 4;
pub(crate) const ACCESS_SMRAM_RX: u32 = 5;
pub(crate) const ACCESS_SMRAM_RW: u32 = 6;
pub(crate) const ACCESS_SMRAM_RWX: u32 = 7;
pub(crate) const MEM_READ_DISABLED: u32 = 16400;
pub(crate) const MEM_READ_INTERNAL: u32 = 1025;
pub(crate) const MEM_READ_EXTERNAL: u32 = 0;
pub(crate) const MEM_READ_ROMCS: u32 = 2050;
pub(crate) const MEM_READ_EXTANY: u32 = 2050;
pub(crate) const MEM_READ_EXTERNAL_EX: u32 = 0;
pub(crate) const MEM_READ_SMRAM: u32 = 4100;
pub(crate) const MEM_READ_CACHE: u32 = 8200;
pub(crate) const MEM_READ_SMRAM_EX: u32 = 4;
pub(crate) const MEM_EXEC_SMRAM: u32 = 4;
pub(crate) const MEM_READ_SMRAM_2: u32 = 4096;
pub(crate) const MEM_READ_DISABLED_EX: u32 = 16400;
pub(crate) const MEM_READ_MASK: u32 = 31775;
pub(crate) const MEM_WRITE_DISABLED: u32 = 512;
pub(crate) const MEM_WRITE_INTERNAL: u32 = 32;
pub(crate) const MEM_WRITE_EXTERNAL: u32 = 0;
pub(crate) const MEM_WRITE_ROMCS: u32 = 64;
pub(crate) const MEM_WRITE_EXTANY: u32 = 64;
pub(crate) const MEM_WRITE_SMRAM: u32 = 128;
pub(crate) const MEM_WRITE_CACHE: u32 = 256;
pub(crate) const MEM_WRITE_DISABLED_EX: u32 = 16400;
pub(crate) const MEM_WRITE_MASK: u32 = 992;
pub(crate) const MEM_MAPPING_EXTERNAL: u32 = 1;
pub(crate) const MEM_MAPPING_INTERNAL: u32 = 2;
pub(crate) const MEM_MAPPING_ROM_WS: u32 = 4;
pub(crate) const MEM_MAPPING_IS_ROM: u32 = 8;
pub(crate) const MEM_MAPPING_ROM: u32 = 12;
pub(crate) const MEM_MAPPING_ROMCS: u32 = 16;
pub(crate) const MEM_MAPPING_SMRAM: u32 = 32;
pub(crate) const MEM_MAPPING_CACHE: u32 = 64;
pub(crate) const MEM_GRANULARITY_BITS: u32 = 12;
pub(crate) const MEM_GRANULARITY_SIZE: u32 = 4096;
pub(crate) const MEM_GRANULARITY_HBOUND: u32 = 4094;
pub(crate) const MEM_GRANULARITY_QBOUND: u32 = 4092;
pub(crate) const MEM_GRANULARITY_MASK: u32 = 4095;
pub(crate) const MEM_GRANULARITY_HMASK: u32 = 2047;
pub(crate) const MEM_GRANULARITY_QMASK: u32 = 1023;
pub(crate) const MEM_GRANULARITY_PMASK: u32 = 511;
pub(crate) const MEM_MAPPINGS_NO: u32 = 1048576;
pub(crate) const MEM_GRANULARITY_PAGE: u32 = 0;
pub(crate) const MEM_GRANULARITY_BASE: i32 = -4096;
pub(crate) const FLAG_INT: u32 = 1;
pub(crate) const FLAG_INV: u32 = 2;
pub(crate) const FLAG_AUX: u32 = 4;
pub(crate) const FLAG_REP: u32 = 8;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct __fsid_t {
    pub(crate) __val: [libc::c_int; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub(crate) struct __mbstate_t {
    pub(crate) __count: libc::c_int,
    pub(crate) __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub(crate) union __mbstate_t__bindgen_ty_1 {
    pub(crate) __wch: libc::c_uint,
    pub(crate) __wchb: [libc::c_char; 4usize],
}

extern "C" {
    pub(crate) fn remove(__filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub(crate) fn renameat(
        __oldfd: libc::c_int,
        __old: *const libc::c_char,
        __newfd: libc::c_int,
        __new: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn setbuffer(__stream: *mut FILE, __buf: *mut libc::c_char, __size: size_t);
}
extern "C" {
    pub(crate) fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub(crate) fn fprintf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub(crate) fn printf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub(crate) fn sprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vfprintf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vprintf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vsprintf(
        __s: *mut libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn snprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vsnprintf(
        __s: *mut libc::c_char,
        __maxlen: libc::c_ulong,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vdprintf(
        __fd: libc::c_int,
        __fmt: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn dprintf(__fd: libc::c_int, __fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub(crate) fn fscanf(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub(crate) fn scanf(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub(crate) fn sscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
pub(crate) type _Float32 = f32;
pub(crate) type _Float64 = f64;
pub(crate) type _Float32x = f64;
pub(crate) type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub(crate) fn fscanf1(__stream: *mut FILE, __format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub(crate) fn scanf1(__format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub(crate) fn sscanf1(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vfscanf(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vscanf(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub(crate) fn vsscanf(
        __s: *const libc::c_char,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub(crate) fn vfscanf1(
        __s: *mut FILE,
        __format: *const libc::c_char,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub(crate) fn vscanf1(__format: *const libc::c_char, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub(crate) fn ctermid(__s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub(crate) fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub(crate) fn ftrylockfile(__stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub(crate) fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub(crate) fn __uflow(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub(crate) fn __overflow(arg1: *mut FILE, arg2: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub(crate) struct state_t {
    pub(crate) _bitfield_align_1: [u8; 0],
    pub(crate) _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_state_t() {
    assert_eq!(
        ::std::mem::size_of::<state_t>(),
        2usize,
        concat!("Size of: ", stringify!(state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<state_t>(),
        2usize,
        concat!("Alignment of ", stringify!(state_t))
    );
}
impl state_t {
    #[inline]
    pub(crate) fn x(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_x(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn w(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_w(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn r(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_r(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn pad(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub(crate) fn set_pad(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub(crate) fn new_bitfield_1(
        x: u16,
        w: u16,
        r: u16,
        pad: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let x: u16 = unsafe { ::std::mem::transmute(x) };
            x as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let w: u16 = unsafe { ::std::mem::transmute(w) };
            w as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let r: u16 = unsafe { ::std::mem::transmute(r) };
            r as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pad: u16 = unsafe { ::std::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub(crate) union mem_state_t {
    pub(crate) vals: [u16; 4usize],
    pub(crate) states: [state_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct _mem_mapping_ {
    pub(crate) prev: *mut _mem_mapping_,
    pub(crate) next: *mut _mem_mapping_,
    pub(crate) enable: libc::c_int,
    pub(crate) base: u32,
    pub(crate) size: u32,
    pub(crate) read_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u8>,
    pub(crate) read_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u16>,
    pub(crate) read_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, priv_: *mut libc::c_void) -> u32>,
    pub(crate) write_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u8, priv_: *mut libc::c_void)>,
    pub(crate) write_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u16, priv_: *mut libc::c_void)>,
    pub(crate) write_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u32, priv_: *mut libc::c_void)>,
    pub(crate) exec: *mut u8,
    pub(crate) flags: u32,
    pub(crate) p: *mut libc::c_void,
}
pub(crate) type mem_mapping_t = _mem_mapping_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct _page_ {
    pub(crate) write_b:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u8, p: *mut _page_)>,
    pub(crate) write_w:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u16, p: *mut _page_)>,
    pub(crate) write_l:
        ::std::option::Option<unsafe extern "C" fn(addr: u32, val: u32, p: *mut _page_)>,
    pub(crate) mem: *mut u8,
    pub(crate) code_present_mask: [u64; 4usize],
    pub(crate) dirty_mask: [u64; 4usize],
    pub(crate) block: [*mut codeblock_t; 4usize],
    pub(crate) block_2: [*mut codeblock_t; 4usize],
    pub(crate) head: *mut codeblock_t,
}
pub(crate) type page_t = _page_;
extern "C" {
    pub(crate) static mut ram: *mut u8;
}
extern "C" {
    pub(crate) static mut ram2: *mut u8;
}
extern "C" {
    pub(crate) static mut rammask: u32;
}
extern "C" {
    pub(crate) static mut rom: *mut u8;
}
extern "C" {
    pub(crate) static mut biosmask: u32;
}
extern "C" {
    pub(crate) static mut biosaddr: u32;
}
extern "C" {
    pub(crate) static mut readlookup: [libc::c_int; 256usize];
}
extern "C" {
    pub(crate) static mut readlookup2: *mut usize;
}
extern "C" {
    pub(crate) static mut old_rl2: usize;
}
extern "C" {
    pub(crate) static mut uncached: u8;
}
extern "C" {
    pub(crate) static mut readlnext: libc::c_int;
}
extern "C" {
    pub(crate) static mut writelookup: [libc::c_int; 256usize];
}
extern "C" {
    pub(crate) static mut writelookup2: *mut usize;
}
extern "C" {
    pub(crate) static mut writelnext: libc::c_int;
}
extern "C" {
    pub(crate) static mut ram_mapped_addr: [u32; 64usize];
}
extern "C" {
    pub(crate) static mut ram_low_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_mid_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_remapped_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_high_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut ram_2gb_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut bios_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut bios_high_mapping: mem_mapping_t;
}
extern "C" {
    pub(crate) static mut mem_logical_addr: u32;
}
extern "C" {
    pub(crate) static mut pages: *mut page_t;
}
extern "C" {
    pub(crate) static mut page_lookup: *mut *mut page_t;
}
extern "C" {
    pub(crate) static mut get_phys_virt: u32;
}
extern "C" {
    pub(crate) static mut get_phys_phys: u32;
}
extern "C" {
    pub(crate) static mut shadowbios: libc::c_int;
}
extern "C" {
    pub(crate) static mut shadowbios_write: libc::c_int;
}
extern "C" {
    pub(crate) static mut readlnum: libc::c_int;
}
extern "C" {
    pub(crate) static mut writelnum: libc::c_int;
}
extern "C" {
    pub(crate) static mut memspeed: [libc::c_int; 11usize];
}
extern "C" {
    pub(crate) static mut mmu_perm: libc::c_int;
}
extern "C" {
    pub(crate) static mut high_page: u8;
}
extern "C" {
    pub(crate) static mut mem_a20_state: libc::c_int;
}
extern "C" {
    pub(crate) static mut mem_a20_alt: libc::c_int;
}
extern "C" {
    pub(crate) static mut mem_a20_key: libc::c_int;
}
extern "C" {
    pub(crate) fn read_mem_b(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn read_mem_w(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn write_mem_b(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn write_mem_w(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn readmembl(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn writemembl(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn readmemwl(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn writememwl(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn readmemll(addr: u32) -> u32;
}
extern "C" {
    pub(crate) fn writememll(addr: u32, val: u32);
}
extern "C" {
    pub(crate) fn readmemql(addr: u32) -> u64;
}
extern "C" {
    pub(crate) fn writememql(addr: u32, val: u64);
}
extern "C" {
    pub(crate) fn readmembl_no_mmut(addr: u32, a64: u32) -> u8;
}
extern "C" {
    pub(crate) fn writemembl_no_mmut(addr: u32, a64: u32, val: u8);
}
extern "C" {
    pub(crate) fn readmemwl_no_mmut(addr: u32, a64: *mut u32) -> u16;
}
extern "C" {
    pub(crate) fn writememwl_no_mmut(addr: u32, a64: *mut u32, val: u16);
}
extern "C" {
    pub(crate) fn readmemll_no_mmut(addr: u32, a64: *mut u32) -> u32;
}
extern "C" {
    pub(crate) fn writememll_no_mmut(addr: u32, a64: *mut u32, val: u32);
}
extern "C" {
    pub(crate) fn do_mmutranslate(addr: u32, a64: *mut u32, num: libc::c_int, write: libc::c_int);
}
extern "C" {
    pub(crate) fn getpccache(a: u32) -> *mut u8;
}
extern "C" {
    pub(crate) fn mmutranslatereal(addr: u32, rw: libc::c_int) -> u64;
}
extern "C" {
    pub(crate) fn mmutranslatereal32(addr: u32, rw: libc::c_int) -> u32;
}
extern "C" {
    pub(crate) fn addreadlookup(virt: u32, phys: u32);
}
extern "C" {
    pub(crate) fn addwritelookup(virt: u32, phys: u32);
}
extern "C" {
    pub(crate) fn mem_mapping_set(
        arg1: *mut mem_mapping_t,
        base: u32,
        size: u32,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
        exec: *mut u8,
        flags: u32,
        p: *mut libc::c_void,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_add(
        arg1: *mut mem_mapping_t,
        base: u32,
        size: u32,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
        exec: *mut u8,
        flags: u32,
        p: *mut libc::c_void,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_set_handler(
        arg1: *mut mem_mapping_t,
        read_b: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u8>,
        read_w: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u16>,
        read_l: ::std::option::Option<unsafe extern "C" fn(addr: u32, p: *mut libc::c_void) -> u32>,
        write_b: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u8, p: *mut libc::c_void),
        >,
        write_w: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u16, p: *mut libc::c_void),
        >,
        write_l: ::std::option::Option<
            unsafe extern "C" fn(addr: u32, val: u32, p: *mut libc::c_void),
        >,
    );
}
extern "C" {
    pub(crate) fn mem_mapping_set_p(arg1: *mut mem_mapping_t, p: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_mapping_set_addr(arg1: *mut mem_mapping_t, base: u32, size: u32);
}
extern "C" {
    pub(crate) fn mem_mapping_set_exec(arg1: *mut mem_mapping_t, exec: *mut u8);
}
extern "C" {
    pub(crate) fn mem_mapping_disable(arg1: *mut mem_mapping_t);
}
extern "C" {
    pub(crate) fn mem_mapping_enable(arg1: *mut mem_mapping_t);
}
extern "C" {
    pub(crate) fn mem_mapping_recalc(base: u64, size: u64);
}
extern "C" {
    pub(crate) fn mem_set_access(bitmap: u8, mode: libc::c_int, base: u32, size: u32, access: u16);
}
extern "C" {
    pub(crate) fn mem_readb_phys(addr: u32) -> u8;
}
extern "C" {
    pub(crate) fn mem_readw_phys(addr: u32) -> u16;
}
extern "C" {
    pub(crate) fn mem_readl_phys(addr: u32) -> u32;
}
extern "C" {
    pub(crate) fn mem_read_phys(dest: *mut libc::c_void, addr: u32, tranfer_size: libc::c_int);
}
extern "C" {
    pub(crate) fn mem_writeb_phys(addr: u32, val: u8);
}
extern "C" {
    pub(crate) fn mem_writew_phys(addr: u32, val: u16);
}
extern "C" {
    pub(crate) fn mem_writel_phys(addr: u32, val: u32);
}
extern "C" {
    pub(crate) fn mem_write_phys(src: *mut libc::c_void, addr: u32, tranfer_size: libc::c_int);
}
extern "C" {
    pub(crate) fn mem_read_ram(addr: u32, priv_: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn mem_read_ramw(addr: u32, priv_: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn mem_read_raml(addr: u32, priv_: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn mem_write_ram(addr: u32, val: u8, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ramw(addr: u32, val: u16, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_raml(addr: u32, val: u32, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_read_ram_2gb(addr: u32, priv_: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn mem_read_ram_2gbw(addr: u32, priv_: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn mem_read_ram_2gbl(addr: u32, priv_: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn mem_write_ram_2gb(addr: u32, val: u8, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ram_2gbw(addr: u32, val: u16, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_write_ram_2gbl(addr: u32, val: u32, priv_: *mut libc::c_void);
}
extern "C" {
    pub(crate) fn mem_addr_is_ram(addr: u32) -> libc::c_int;
}
extern "C" {
    pub(crate) fn mmutranslate_noabrt(addr: u32, rw: libc::c_int) -> u64;
}
extern "C" {
    pub(crate) fn mem_invalidate_range(start_addr: u32, end_addr: u32);
}
extern "C" {
    pub(crate) fn mem_write_ramb_page(addr: u32, val: u8, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_write_ramw_page(addr: u32, val: u16, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_write_raml_page(addr: u32, val: u32, p: *mut page_t);
}
extern "C" {
    pub(crate) fn mem_flush_write_page(addr: u32, virt: u32);
}
extern "C" {
    pub(crate) fn mem_reset_page_blocks();
}
extern "C" {
    pub(crate) fn flushmmucache();
}
extern "C" {
    pub(crate) fn flushmmucache_nopc();
}
extern "C" {
    pub(crate) fn mmu_invalidate(addr: u32);
}
extern "C" {
    pub(crate) fn mem_a20_init();
}
extern "C" {
    pub(crate) fn mem_a20_recalc();
}
extern "C" {
    pub(crate) fn mem_init();
}
extern "C" {
    pub(crate) fn mem_close();
}
extern "C" {
    pub(crate) fn mem_reset();
}
extern "C" {
    pub(crate) fn mem_remap_top(kb: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct rom_t {
    pub(crate) rom: *mut u8,
    pub(crate) sz: libc::c_int,
    pub(crate) mask: u32,
    pub(crate) mapping: mem_mapping_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct rom_path_t {
    pub(crate) path: [libc::c_char; 1024usize],
    pub(crate) next: *mut rom_path_t,
}
extern "C" {
    pub(crate) static mut rom_paths: rom_path_t;
}
extern "C" {
    pub(crate) fn rom_add_path(path: *const libc::c_char);
}
extern "C" {
    pub(crate) fn rom_read(addr: u32, p: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn rom_readw(addr: u32, p: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn rom_readl(addr: u32, p: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn rom_fopen(fn_: *mut libc::c_char, mode: *mut libc::c_char) -> *mut FILE;
}
extern "C" {
    pub(crate) fn rom_getfile(
        fn_: *mut libc::c_char,
        s: *mut libc::c_char,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_present(fn_: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_load_linear_oddeven(
        fn_: *mut libc::c_char,
        addr: u32,
        sz: libc::c_int,
        off: libc::c_int,
        ptr: *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_load_linear(
        fn_: *mut libc::c_char,
        addr: u32,
        sz: libc::c_int,
        off: libc::c_int,
        ptr: *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_load_interleaved(
        fnl: *mut libc::c_char,
        fnh: *mut libc::c_char,
        addr: u32,
        sz: libc::c_int,
        off: libc::c_int,
        ptr: *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn bios_read(addr: u32, priv_: *mut libc::c_void) -> u8;
}
extern "C" {
    pub(crate) fn bios_readw(addr: u32, priv_: *mut libc::c_void) -> u16;
}
extern "C" {
    pub(crate) fn bios_readl(addr: u32, priv_: *mut libc::c_void) -> u32;
}
extern "C" {
    pub(crate) fn bios_load(
        fn1: *mut libc::c_char,
        fn2: *mut libc::c_char,
        addr: u32,
        sz: libc::c_int,
        off: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn bios_load_linear_combined(
        fn1: *mut libc::c_char,
        fn2: *mut libc::c_char,
        sz: libc::c_int,
        off: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn bios_load_linear_combined2(
        fn1: *mut libc::c_char,
        fn2: *mut libc::c_char,
        fn3: *mut libc::c_char,
        fn4: *mut libc::c_char,
        fn5: *mut libc::c_char,
        sz: libc::c_int,
        off: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn bios_load_linear_combined2_ex(
        fn1: *mut libc::c_char,
        fn2: *mut libc::c_char,
        fn3: *mut libc::c_char,
        fn4: *mut libc::c_char,
        fn5: *mut libc::c_char,
        sz: libc::c_int,
        off: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_init(
        rom: *mut rom_t,
        fn_: *mut libc::c_char,
        address: u32,
        size: libc::c_int,
        mask: libc::c_int,
        file_offset: libc::c_int,
        flags: u32,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_init_oddeven(
        rom: *mut rom_t,
        fn_: *mut libc::c_char,
        address: u32,
        size: libc::c_int,
        mask: libc::c_int,
        file_offset: libc::c_int,
        flags: u32,
    ) -> libc::c_int;
}
extern "C" {
    pub(crate) fn rom_init_interleaved(
        rom: *mut rom_t,
        fn_low: *mut libc::c_char,
        fn_high: *mut libc::c_char,
        address: u32,
        size: libc::c_int,
        mask: libc::c_int,
        file_offset: libc::c_int,
        flags: u32,
    ) -> libc::c_int;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct __va_list_tag {
    pub(crate) gp_offset: libc::c_uint,
    pub(crate) fp_offset: libc::c_uint,
    pub(crate) overflow_arg_area: *mut libc::c_void,
    pub(crate) reg_save_area: *mut libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct codeblock_t {
    pub(crate) _address: u8,
}
